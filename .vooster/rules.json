{
  "rules": [
    {
      "type": "prd",
      "content": "# KingCL AI Growth Planner – Product Requirement Document (PRD)\n\n## 1. 제품 개요\nKingCL AI Growth Planner는 직장인들이 개인 성장 목표를 설정·관리하고 진행 상황을 한눈에 확인하며, AI 기반 코칭으로 실행력을 높이는 웹 기반 SaaS입니다. AI 루틴 자동화 플래너, GPT 성장 코치 챗봇, 성장 대시보드가 핵심 경험을 제공합니다.\n\n## 2. 비전 & 목표\n• 1년 내 베타 출시, 직장인 1,000명 유료(Pro) 전환, 소규모 HR 팀 20곳 팀 요금제 계약\n• 사용자의 목표 달성률을 최소 30% 향상시키는 것을 지표로 삼음\n\n## 3. 타깃 사용자\nPrimary: 20~40대 직장인(개발, 마케팅, 기획 등 지식 노동자)\nSecondary: 소규모 HR 팀(5~50인 조직) – 직원 성장 데이터를 한 계정에서 관리하려는 니즈\n\n## 4. 핵심 페인 포인트\n1) 목표 진행 상황이 한눈에 보이지 않아 동기 부여가 떨어짐\n2) 데이터 기반 개인화 코칭 부재로 지속적인 개선이 어려움\n\n## 5. 사용자 최종 목표\n• 개인 성장 목표를 꾸준히 달성하고 실적을 시각적으로 확인하기\n\n## 6. 주요 기능 (MVP 범위)\n1) AI 루틴 자동화 플래너 – 목표·일정·습관 데이터 기반 자동 할 일 생성\n2) GPT 성장 코치 챗봇 – 진행 상황 분석 후 실시간 피드백 & 질문 응답\n3) 성장 대시보드 – 목표, 완료율, 트렌드를 차트·그래프로 시각화\n\n## 7. 부가 기능 (MVP 포함)\n4) AI 추천 시스템 – 목표에 맞는 액션·콘텐츠·코칭 제안\n5) 캘린더·노션·n8n 연동 – 외부 일정·노트 자동 동기화\n\n## 8. 사용자 스토리 (주요 시나리오)\n• 직장인으로서 분기 목표를 입력하면 플래너가 월·주 단위 실행 계획을 자동 생성한다.\n• 진행률이 50% 아래로 떨어지면 GPT 코치가 원인 분석과 개선 액션을 제안한다.\n• 대시보드에서 주간 완료율과 목표 달성 예측치를 확인한다.\n\n## 9. 성공 지표 (KPIs)\n• 주간 활성 사용자(WAU) 40% 이상\n• 목표 입력 후 첫 4주 내 플래너 재활용률 60% 이상\n• GPT 코치 세션당 만족도 4.5/5 이상\n\n## 10. 수익 모델\n혼합 계층형 요금제\n• 개인 Free: 기본 목표 3개, 대시보드 제한, GPT 코치 월 10회\n• 개인 Pro(₩9,900/월): 무제한 목표, 고급 대시보드, 코치 무제한, AI 추천\n• Team Basic(₩45,000/월, 5인): 팀 대시보드, 역할별 권한, 기본 리포트\n• Team Pro(₩75,000/월, 5인): API·웹훅, 커스텀 리포트, SSO\n\n## 11. 범위 & 우선순위\nMVP = 기능 1~5 + 개인 Free/Pro 결제 플로우 + 팀 계정 구조만(결제는 후행)\n\n## 12. 일정(예상)\n• 0주: 기획 확정\n• 1~4주: UX/UI 디자인 & 프로토타입\n• 5~10주: MVP 개발(Next.js 15 스택)\n• 11~12주: 클로즈드 베타 & 피드백\n• 13~16주: 개선 → 오픈 베타 & 결제 오픈\n\n## 13. 리스크 & 대응\n• AI 추천 품질 저하 → 사용자 피드백 루프 구축해 모델 개선 주기화\n• 개인정보·성과 데이터 보안 → Supabase RLS, 암호화 적용, ISO27001 준비\n• HR 팀용 요구사항 확장 → 팀 기능은 모듈화해 점진적 추가\n\n## 14. 성공을 위한 핵심 가정\n• 직장인은 목표 관리 툴에 월 ₩10,000 지불 의향이 있다.\n• 시각화된 진행률 정보가 목표 달성률을 실질적으로 높인다.\n• GPT 기반 코칭은 텍스트 인터페이스만으로도 충분한 만족도를 준다.\n\n## 15. 향후 로드맵(포스트 MVP)\n• 모바일 앱(React Native)\n• 실시간 협업 코멘트\n• 오프라인 워크숍 연계 프로그램",
      "writedAt": "2025-09-05T08:56:25.621Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: KingCL AI Growth Planner는 Next.js 15 기반의 웹 SaaS로, 직장인들의 개인 성장 목표 설정, 관리, 진행 상황 확인을 돕고 AI 기반 코칭을 제공하여 실행력을 향상시키는 것을 목표로 한다. 핵심 기능은 AI 루틴 자동화 플래너, GPT 성장 코치 챗봇, 성장 대시보드이다.\n- **Core Technology Stack**: Next.js 15, TypeScript, Tailwind CSS, Supabase, @tanstack/react-query, shadcn/ui, lucide-react, es-toolkit, date-fns를 사용하여 개발한다. Next.js는 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG)을 지원하여 초기 로딩 속도를 개선하고 SEO 최적화를 용이하게 한다. Supabase는 인증, 데이터베이스, 스토리지 등의 백엔드 기능을 제공하며, @tanstack/react-query는 서버 상태 관리를 효율적으로 처리한다.\n- **Key Technical Objectives**:\n    - **Performance**: 초기 로딩 속도 2초 이내, API 응답 시간 500ms 이내\n    - **Scalability**: 1,000명의 유료 사용자 및 20개의 팀 요금제를 안정적으로 지원\n    - **Reliability**: 99.9% 이상의 시스템 가용성\n- **Critical Technical Assumptions**:\n    - 직장인들이 목표 관리 툴에 월 ₩10,000 지불 의향이 있다는 가정\n    - 시각화된 진행률 정보가 목표 달성률을 실질적으로 높인다는 가정\n    - GPT 기반 코칭은 텍스트 인터페이스만으로도 충분한 만족도를 준다는 가정\n\n## 2. Tech Stack\n\n| Category              | Technology / Library        | Reasoning (Why it's chosen for this project)                                                                                                                                                                                                                                                                                                                                                             |\n| --------------------- | --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 프레임워크            | Next.js 15                 | 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG), API 라우팅을 지원하여 초기 로딩 속도 개선 및 SEO 최적화에 용이하다. 또한 빠른 개발 속도와 유지보수성을 제공한다.                                                                                                                                                                                                                                                                                          |\n| UI 컴포넌트           | shadcn/ui                   | 재사용 가능한 UI 컴포넌트 라이브러리로, 디자인 시스템을 일관되게 유지하고 개발 생산성을 향상시킨다. Tailwind CSS와 통합되어 스타일링을 간편하게 할 수 있다.                                                                                                                                                                                                                                                                                           |\n| 아이콘                | lucide-react                | 고품질의 벡터 아이콘을 제공하며, React 컴포넌트 형태로 사용하기 간편하다.                                                                                                                                                                                                                                                                                                                                    |\n| 언어                  | TypeScript                  | 정적 타입 검사를 통해 코드의 안정성을 높이고, 개발 과정에서 오류를 사전에 발견할 수 있도록 돕는다. 코드 자동 완성 및 리팩토링 지원으로 개발 생산성을 향상시킨다.                                                                                                                                                                                                                                                                                         |\n| 스타일링              | Tailwind CSS                | 유틸리티 우선(Utility-first) CSS 프레임워크로, 컴포넌트 스타일링을 빠르고 효율적으로 할 수 있다. 반응형 디자인을 쉽게 구현할 수 있으며, 커스터마이징이 용이하다.                                                                                                                                                                                                                                                                                          |\n| 백엔드                | Supabase                    | 인증, 데이터베이스, 스토리지, 실시간 통신 등의 백엔드 기능을 제공하는 오픈 소스 Firebase 대안이다. PostgreSQL 기반으로 안정적이며, 사용하기 쉬운 API와 SDK를 제공한다. RLS(Row Level Security)를 통해 데이터 보안을 강화할 수 있다.                                                                                                                                                                                                                           |\n| 서버 상태 관리        | @tanstack/react-query       | 서버 상태를 효율적으로 관리하고 캐싱, 데이터 동기화 기능을 제공한다. API 요청 및 응답 처리를 간편하게 할 수 있으며, 사용자 경험을 향상시킨다.                                                                                                                                                                                                                                                                                                        |\n| 유틸리티              | es-toolkit                  | 다양한 유틸리티 함수를 제공하여 개발 편의성을 높인다. 문자열 처리, 날짜/시간 처리, 배열 처리 등 다양한 기능을 제공한다.                                                                                                                                                                                                                                                                                                                                  |\n| 날짜/시간 처리        | date-fns                    | 날짜 및 시간 처리를 위한 라이브러리로, 다양한 형식의 날짜/시간 변환 및 계산 기능을 제공한다. Moment.js에 비해 가볍고 모듈화되어 있어 번들 크기를 줄일 수 있다.                                                                                                                                                                                                                                                                                                   |\n| AI 모델 연동          | (추가 필요)                | GPT 모델 연동을 위한 라이브러리 또는 API 클라이언트를 추가해야 한다. OpenAI API를 직접 사용하거나, Langchain과 같은 추상화 레이어를 사용할 수 있다.                                                                                                                                                                                                                                                                                                     |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Next.js Application)**:\n    - **UI Components**: shadcn/ui, lucide-react를 사용하여 사용자 인터페이스를 구성한다.\n    - **State Management**: @tanstack/react-query를 사용하여 서버 상태를 관리하고, React Context API를 사용하여 전역 상태를 관리한다.\n    - **Routing**: Next.js의 파일 기반 라우팅 시스템을 사용하여 페이지 간 이동을 처리한다.\n- **Backend (Supabase)**:\n    - **Authentication**: Supabase Auth를 사용하여 사용자 인증 및 권한 관리를 처리한다. OAuth를 지원하여 Google 계정 연동을 구현한다.\n    - **Database**: PostgreSQL 데이터베이스를 사용하여 사용자 데이터, 목표 데이터, 플래너 데이터 등을 저장한다. RLS(Row Level Security)를 적용하여 데이터 보안을 강화한다.\n    - **API**: Supabase Functions 또는 Next.js API Routes를 사용하여 클라이언트 요청을 처리하고 데이터베이스와 상호 작용한다.\n- **AI Integration (GPT 성장 코치)**:\n    - **GPT API**: OpenAI API 또는 Langchain을 사용하여 GPT 모델과 연동한다.\n    - **Prompt Engineering**: 사용자 입력 및 목표 데이터를 기반으로 GPT 모델에 적절한 프롬프트를 생성한다.\n    - **Response Processing**: GPT 모델의 응답을 파싱하고 사용자에게 적절한 형식으로 제공한다.\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[Frontend (Next.js)] --> B[Backend (Supabase)]\n    A --> C[AI Integration (GPT API)]\n    B --> D[Database (PostgreSQL)]\n    C --> D\n```\n\n- **Frontend (Next.js)**: 사용자 인터페이스를 제공하고, 사용자 입력을 받아 API 요청을 Backend (Supabase) 또는 AI Integration (GPT API)로 전송한다.\n- **Backend (Supabase)**: 사용자 인증, 데이터베이스 쿼리, API 요청 처리를 담당한다. 데이터베이스 (PostgreSQL)에 데이터를 저장하고 검색한다.\n- **AI Integration (GPT API)**: 사용자 입력 및 목표 데이터를 기반으로 GPT 모델에 프롬프트를 전송하고, 응답을 받아 Frontend (Next.js)로 반환한다.\n- **Database (PostgreSQL)**: 사용자 데이터, 목표 데이터, 플래너 데이터 등을 저장한다. Supabase RLS를 통해 데이터 보안을 강화한다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 사용자 관리, 목표 관리, 플래너 관리, AI 코칭 등 비즈니스 도메인별로 코드를 분리한다.\n- **Layer-Based Architecture**: 프레젠테이션 레이어 (UI 컴포넌트), 비즈니스 로직 레이어 (서비스), 데이터 접근 레이어 (리포지토리), 인프라 레이어 (API 클라이언트)로 분리한다.\n- **Feature-Based Modules**: 각 기능별로 관련 파일들을 모듈화하여 관리한다. 예를 들어, 목표 관리 기능은 `src/modules/goals` 디렉토리에 관련 컴포넌트, 서비스, API를 포함한다.\n- **Shared Components**: 공통 유틸리티, 타입, 재사용 가능한 컴포넌트는 `src/shared` 디렉토리에 저장한다.\n\n**Universal File & Folder Structure**\n```\n/\n├── next.config.js\n├── package.json\n├── tsconfig.json\n├── .eslintrc.js\n├── src/\n│   ├── pages/                # Next.js 페이지 (라우팅)\n│   │   ├── api/              # API Routes\n│   │   ├── _app.tsx          # Custom App\n│   │   ├── _document.tsx     # Custom Document\n│   │   └── index.tsx         # 메인 페이지\n│   ├── components/           # 재사용 가능한 UI 컴포넌트\n│   │   ├── ui/               # shadcn/ui 컴포넌트\n│   │   ├── common/           # 공통 컴포넌트\n│   │   └── ...\n│   ├── modules/              # 도메인별 모듈\n│   │   ├── users/            # 사용자 관리\n│   │   │   ├── components/\n│   │   │   ├── services/\n│   │   │   ├── api/\n│   │   │   └── types/\n│   │   ├── goals/            # 목표 관리\n│   │   │   ├── components/\n│   │   │   ├── services/\n│   │   │   ├── api/\n│   │   │   └── types/\n│   │   ├── planner/          # 플래너 관리\n│   │   │   ├── components/\n│   │   │   ├── services/\n│   │   │   ├── api/\n│   │   │   └── types/\n│   │   └── coaching/         # AI 코칭\n│   │       ├── components/\n│   │       ├── services/\n│   │       ├── api/\n│   │       └── types/\n│   ├── shared/               # 공통 유틸리티 및 타입\n│   │   ├── utils/\n│   │   ├── types/\n│   │   ├── hooks/\n│   │   └── components/\n│   ├── styles/              # 전역 스타일\n│   │   └── globals.css\n│   └── lib/                 # Supabase 클라이언트 및 설정\n│       └── supabaseClient.ts\n└── public/\n    ├── images/\n    └── ...\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: 클라이언트는 API 요청을 통해 서버와 통신한다. Next.js API Routes 또는 Supabase Functions를 사용하여 API 엔드포인트를 정의한다.\n- **Database Interaction**: Supabase 클라이언트를 사용하여 PostgreSQL 데이터베이스와 상호 작용한다. @tanstack/react-query를 사용하여 데이터 캐싱 및 동기화를 처리한다.\n- **External Service Integration**: OpenAI API를 사용하여 GPT 모델과 연동한다. API 키를 안전하게 관리하고, 에러 처리 및 재시도 로직을 구현한다.\n- **Real-time Communication**: (MVP 범위 외) 실시간 협업 코멘트 기능을 위해 Supabase Realtime 또는 WebSocket을 사용할 수 있다.\n- **Data Synchronization**: @tanstack/react-query를 사용하여 서버 상태와 클라이언트 상태를 동기화한다. 데이터 변경 시 자동으로 UI를 업데이트한다.\n\n## 4. Performance & Optimization Strategy\n- **Code Splitting**: Next.js의 코드 스플리팅 기능을 활용하여 초기 로딩에 필요한 코드만 로드하고, 나머지 코드는 필요할 때 동적으로 로드한다.\n- **Image Optimization**: Next.js의 Image 컴포넌트를 사용하여 이미지 크기를 최적화하고, lazy loading을 적용하여 초기 로딩 속도를 개선한다.\n- **Caching**: @tanstack/react-query를 사용하여 API 응답을 캐싱하고, CDN을 사용하여 정적 자원을 캐싱한다.\n- **Database Optimization**: 데이터베이스 쿼리를 최적화하고, 인덱싱을 적용하여 검색 속도를 향상시킨다. Supabase RLS를 사용하여 데이터 접근 권한을 제한하고, 불필요한 데이터 로드를 방지한다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js 프로젝트 설정, Supabase 프로젝트 설정, 인증 기능 구현, 데이터베이스 스키마 정의\n- **Essential Features**: AI 루틴 자동화 플래너, GPT 성장 코치 챗봇, 성장 대시보드 기본 기능 구현, 개인 Free/Pro 결제 플로우 구현\n- **Basic Security**: Supabase RLS 적용, 암호화 적용, API 키 보안 관리\n- **Development Setup**: 개발 환경 설정, CI/CD 파이프라인 구축 (Vercel 또는 Netlify)\n- **Timeline**: 5~10주\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: AI 추천 시스템 구현, 캘린더·노션·n8n 연동 구현, 팀 계정 구조 구현 (결제는 후행)\n- **Performance Optimization**: 코드 스플리팅, 이미지 최적화, 캐싱 전략 적용, 데이터베이스 쿼리 최적화\n- **Enhanced Security**: 추가적인 보안 기능 구현 (예: rate limiting, XSS 방지), ISO27001 준비\n- **Monitoring Implementation**: 로깅 및 모니터링 시스템 구축 (Sentry 또는 Datadog)\n- **Timeline**: 13~16주\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**:\n    - GPT 모델의 응답 품질 저하: 사용자 피드백 루프 구축, 프롬프트 엔지니어링 개선, 모델 재학습\n    - Supabase 의존성: Supabase 장애 발생 시 서비스 중단 가능성, 백업 및 복구 전략 수립, 다른 백엔드 서비스로의 전환 가능성 고려\n- **Performance Risks**:\n    - 초기 로딩 속도 저하: 코드 스플리팅, 이미지 최적화, 캐싱 전략 적용\n    - API 응답 시간 지연: 데이터베이스 쿼리 최적화, API 엔드포인트 캐싱\n- **Security Risks**:\n    - 개인정보 유출: Supabase RLS 적용, 데이터 암호화, 정기적인 보안 감사\n    - XSS 공격: 입력 값 검증, HTML 이스케이프 처리\n- **Integration Risks**:\n    - 외부 서비스 API 장애: 에러 처리 및 재시도 로직 구현, 대체 API 사용 고려\n- **Mitigation Strategies**:\n    - 기술적 문제 발생 시 빠른 해결을 위한 기술 지원팀 운영\n    - 코드 리뷰 및 테스트 자동화를 통해 코드 품질 유지\n    - 정기적인 보안 점검 및 취약점 분석\n\n### Project Delivery Risks\n- **Timeline Risks**:\n    - 개발 일정 지연: 스프린트 계획, 데일리 스크럼, 칸반 보드 사용\n    - 요구사항 변경: 변경 관리 프로세스 수립, 우선순위 재조정\n- **Resource Risks**:\n    - 개발 인력 부족: 추가 인력 확보, 아웃소싱 고려\n    - 핵심 개발자 이탈: 지식 공유 및 문서화, 백업 개발자 지정\n- **Quality Risks**:\n    - 코드 품질 저하: 코드 리뷰, 테스트 자동화, 코딩 컨벤션 준수\n    - 버그 발생: QA 테스트, 유닛 테스트, 통합 테스트\n- **Deployment Risks**:\n    - 배포 실패: 롤백 전략 수립, 스테이징 환경 테스트\n    - 환경 설정 오류: IaC (Infrastructure as Code) 도구 사용 (Terraform 또는 Pulumi)\n- **Contingency Plans**:\n    - 계획 변경 시 유연하게 대처할 수 있도록 예비 자원 확보\n    - 위험 발생 시 신속하게 대응할 수 있도록 비상 연락망 구축\n",
      "writedAt": "2025-09-05T08:56:25.621Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-09-05T08:56:25.621Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-09-05T08:56:25.621Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-09-05T08:56:25.621Z"
    }
  ]
}